{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar typeHandlers = require('./types');\n\nvar detector = require('./detector'); // Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\n\n\nvar MaxBufferSize = 512 * 1024;\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\n\nfunction lookup(buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  var type = detector(buffer, filepath); // find an appropriate handler for this file type\n\n  if (type in typeHandlers) {\n    var size = typeHandlers[type].calculate(buffer, filepath);\n\n    if (size !== false) {\n      size.type = type;\n      return size;\n    }\n  } // throw up, if we don't understand the file\n\n\n  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n *\n * The callback will be called after the process has completed. The\n * callback's first argument will be an error (or null). The second argument\n * will be the Buffer, if the operation was successful.\n *\n * @param {String} filepath\n * @param {Function} callback\n */\n\n\nfunction asyncFileToBuffer(filepath, callback) {\n  // open the file in read only mode\n  fs.open(filepath, 'r', function (err, descriptor) {\n    if (err) {\n      return callback(err);\n    }\n\n    fs.fstat(descriptor, function (err, stats) {\n      if (err) {\n        return callback(err);\n      }\n\n      var size = stats.size;\n\n      if (size <= 0) {\n        return callback(new Error('File size is not greater than 0 —— ' + filepath));\n      }\n\n      var bufferSize = Math.min(size, MaxBufferSize);\n      var buffer = new Buffer(bufferSize); // read first buffer block from the file, asynchronously\n\n      fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {\n        if (err) {\n          return callback(err);\n        } // close the file, we are done\n\n\n        fs.close(descriptor, function (err) {\n          callback(err, buffer);\n        });\n      });\n    });\n  });\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\n\n\nfunction syncFileToBuffer(filepath) {\n  // read from the file, synchronously\n  var descriptor = fs.openSync(filepath, 'r');\n  var size = fs.fstatSync(descriptor).size;\n  var bufferSize = Math.min(size, MaxBufferSize);\n  var buffer = new Buffer(bufferSize);\n  fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n  fs.closeSync(descriptor);\n  return buffer;\n}\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function} callback - optional function for async detection\n */\n\n\nmodule.exports = function (input, callback) {\n  // Handle buffer input\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  } // input should be a string at this point\n\n\n  if (typeof input !== 'string') {\n    throw new TypeError('invalid invocation');\n  } // resolve the file path\n\n\n  var filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    asyncFileToBuffer(filepath, function (err, buffer) {\n      if (err) {\n        return callback(err);\n      } // return the dimensions\n\n\n      var dimensions;\n\n      try {\n        dimensions = lookup(buffer, filepath);\n      } catch (e) {\n        err = e;\n      }\n\n      callback(err, dimensions);\n    });\n  } else {\n    var buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n};\n\nmodule.exports.types = Object.keys(typeHandlers);","map":{"version":3,"sources":["C:/Users/kenny/Projects/djangotutorials/drf_react_project/react_frontend/blogapi/node_modules/image-size/lib/index.js"],"names":["fs","require","path","typeHandlers","detector","MaxBufferSize","lookup","buffer","filepath","type","size","calculate","TypeError","asyncFileToBuffer","callback","open","err","descriptor","fstat","stats","Error","bufferSize","Math","min","Buffer","read","close","syncFileToBuffer","openSync","fstatSync","readSync","closeSync","module","exports","input","isBuffer","resolve","dimensions","e","types","Object","keys"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar typeHandlers = require('./types');\nvar detector = require('./detector');\n\n// Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nvar MaxBufferSize = 512*1024;\n\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\nfunction lookup (buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  var type = detector(buffer, filepath);\n\n  // find an appropriate handler for this file type\n  if (type in typeHandlers) {\n    var size = typeHandlers[type].calculate(buffer, filepath);\n    if (size !== false) {\n      size.type = type;\n      return size;\n    }\n  }\n\n  // throw up, if we don't understand the file\n  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n\n/**\n * Reads a file into a buffer.\n *\n * The callback will be called after the process has completed. The\n * callback's first argument will be an error (or null). The second argument\n * will be the Buffer, if the operation was successful.\n *\n * @param {String} filepath\n * @param {Function} callback\n */\nfunction asyncFileToBuffer (filepath, callback) {\n  // open the file in read only mode\n  fs.open(filepath, 'r', function (err, descriptor) {\n    if (err) { return callback(err); }\n    fs.fstat(descriptor, function (err, stats) {\n      if (err) { return callback(err); }\n      var size = stats.size;\n      if (size <= 0) {\n        return callback(new Error('File size is not greater than 0 —— ' + filepath));\n      }\n      var bufferSize = Math.min(size, MaxBufferSize);\n      var buffer = new Buffer(bufferSize);\n      // read first buffer block from the file, asynchronously\n      fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {\n        if (err) { return callback(err); }\n        // close the file, we are done\n        fs.close(descriptor, function (err) {\n          callback(err, buffer);\n        });\n      });\n    });\n  });\n}\n\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\nfunction syncFileToBuffer (filepath) {\n  // read from the file, synchronously\n  var descriptor = fs.openSync(filepath, 'r');\n  var size = fs.fstatSync(descriptor).size;\n  var bufferSize = Math.min(size, MaxBufferSize);\n  var buffer = new Buffer(bufferSize);\n  fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n  fs.closeSync(descriptor);\n  return buffer;\n}\n\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function} callback - optional function for async detection\n */\nmodule.exports = function (input, callback) {\n\n  // Handle buffer input\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  }\n\n  // input should be a string at this point\n  if (typeof input !== 'string') {\n    throw new TypeError('invalid invocation');\n  }\n\n  // resolve the file path\n  var filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    asyncFileToBuffer(filepath, function (err, buffer) {\n      if (err) { return callback(err); }\n\n      // return the dimensions\n      var dimensions;\n      try {\n        dimensions = lookup(buffer, filepath);\n      } catch (e) {\n        err = e;\n      }\n      callback(err, dimensions);\n    });\n  } else {\n    var buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n};\n\nmodule.exports.types = Object.keys(typeHandlers);\n"]},"metadata":{},"sourceType":"script"}